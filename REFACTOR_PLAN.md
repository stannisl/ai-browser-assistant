# REFACTOR_PLAN.md

## Список проблем

### 1. Дублирование кода между agent.go и executor.go

**Проблема**: Оба файла содержат реализацию одной и той же логики выполнения инструментов

**Секции с дублированием:**
- `extractPage()` в agent.go:217-225 (используется в executeToolImpl)
- `executeExtractPage()` в executor.go:14-20 (НЕ ИСПОЛЬЗУЕТСЯ)

**Последствия**: code duplication, непонятное владение кодом, сложно поддерживать

### 2. executor.go практически не используется

**Проблема**: Файл executor.go содержит все функции для выполнения инструментов, но НИ ОДНА из них не вызывается из agent.go

**Последствия**: 
- Бесполезный файл
- agent.go использует монолитный executeToolImpl вместо dispatcher
- Дублирование всех инструментов в двух местах

### 3. Баги в парсинге аргументов инструментов

**Проблема**: agent.go использует map[type]interface{} вместо JSON unmarshaling, что приводит к ошибкам

**Дефекты:**
- navigate: агент.go:197-200 - использует tc.Arguments["url"].(string) без проверки типа
- click: агент.go:204-207 - использует float64 вместо int (JSON числа парсятся как float64!)
- type_text: агент.go:211-218 - та же проблема с float64
- scroll: агент.go:222-225 - использует string, но нет валидации
- wait: агент.go:229-232 - использует float64 вместо int
- report: агент.go:244-248 - использует string, нет валидации

**Важное замечание**: JSON unmarshaling в executor.go работает корректно для всех инструментов

### 4. Проблемы с flow выполнения

**Проблема**: Сложная логика flow с вложенными условиями и дублированным кодом

**Дефекты:**
- Логика трассировки tool name (агент.go:91-99, 116-124) дублируется
- Нет чёткого разделения: что вызывается из Run() vs что вызывается из executeTool()
- Потенциальные бесконечные циклы без защиты от них
- Неочевидная структура вызовов

### 5. Отсутствие валидации инструментов

**Проблема**: Нет единообразной валидации аргументов перед выполнением

**Дефекты:**
- Нет проверок на nil аргументы
- Нет проверок на пустые строки
- Нет проверок на диапазоны значений (например, wait: 0-10 секунд)

### 6. Неправильное использование executor.go

**Проблема**: executor.go содержит отдельные функции для каждого инструмента, но agent.go игнорирует их

**Последствия**: Логика разбросана, executeToolImpl содержит кучу switch-case

---

## Порядок исправления

### Step 1: Интеграция executor.go в agent.go
**Зависимость**: agent.go зависит от extractor, browser

**Что делать:**
1. Изменить `executeToolImpl` в agent.go чтобы вызывать соответствующие функции из executor.go
2. Удалить дублирующийся код из executeToolImpl
3. Убрать `extractPage` из agent.go (использовать `executeExtractPage` из executor.go)

**Ожидаемый результат:** agent.go использует dispatcher-паттерн с executor.go

### Step 2: Исправление парсинга аргументов
**Зависимость**: после Step 1, когда инструменты вызываются из executor.go

**Что делать:**
1. Исправить парсинг аргументов во всех инструментах executor.go:
   - click: использовать int вместо float64
   - type_text: использовать int вместо float64  
   - navigate, scroll, wait, report: добавить валидацию типов
2. Добавить JSON unmarshaling вместо map[type]interface{}
3. Добавить проверки на nil и пустые значения

**Ожидаемый результат:** Все инструменты корректно парсят аргументы с валидацией

### Step 3: Упрощение flow выполнения
**Зависимость**: после Step 1

**Что делать:**
1. Убрать дублирующуюся логику трассировки tool name
2. Создать единый механизм отслеживания tool calls
3. Разделить ответственность: agent.Run() только запускает цикл, executeTool() dispatches к executor'ам
4. Упростить логику с возможными циклами

**Ожидаемый результат:** Чёткий, простой flow с одной точкой входа для инструментов

### Step 4: Дополнение недостающих инструментов
**Зависимость**: после Step 1

**Что делать:**
1. Проверить: каких инструментов нет в executor.go?
2. Добавить недостающие инструменты с JSON parsing
3. Проверить: extract_page есть ли с правильным JSON parsing?

**Ожидаемый результат:** Все инструменты инструментария реализованы в executor.go

### Step 5: Улучшение валидации
**Зависимость**: после Step 2

**Что делать:**
1. Добавить валидацию для всех аргументов
2. Добавить диапазонные проверки (например, wait: 1-10 секунд)
3. Добавить обработку ошибок парсинга с понятными сообщениями

**Ожидаемый результат:** Все инструменты валидируют входные данные

### Step 6: Тестирование и удаление неиспользуемого кода
**Зависимость**: после всех предыдущих шагов

**Что делать:**
1. Запустить все тесты
2. Проверить, что executor.go полностью используется
3. Проверить, что agent.go использует только dispatcher
4. Удалить всё неиспользуемое (избыточное)

**Ожидаемый результат:** Clean code без дублирования

---

## Зависимости между файлами

```
agent.go
├── зависит от: 
│   ├── extractor.Extractor (для extract_page)
│   └── browser.Manager (для navigate, click, type, scroll)
├── должен использовать:
│   └── executor.go функции (после рефакторинга)
└── должен удалить:
    └── дублирующийся код extractPage и executeToolImpl

executor.go
├── должен быть использован:
│   └── agent.executeToolImpl (после рефакторинга)
└── должен содержать:
    ├── все инструменты из agent.executeToolImpl
    └── все инструменты из agent.extractPage

extractor/extractor.go
└── используется: 
    ├── agent.executeToolImpl (для extract_page)
    └── executor.executeExtractPage (для extract_page)

browser/browser.go
└── используется:
    ├── agent.executeToolImpl (navigate, click, type, scroll)
    └── executor функции (navigate, click, type, scroll)
```

---

## Краткая сводка

1. **Критично**: executor.go не используется, код дублируется
2. **Срочно**: Исправить парсинг аргументов (особенно float64 -> int для click/type_text)
3. **Рекомендуется**: Упростить flow выполнения agent.go
4. **Лучше**: Добавить полную валидацию аргументов
5. **Важно**: После рефакторинга убедиться что нет неиспользуемого кода
